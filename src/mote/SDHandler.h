#ifndef __SDGandler_h__
#define __SDGandler_h__

#include <map>

#include "f_util.h"
#include "ff.h"

#include "constants.h"
#include "Config.h"
#include "Log.h"

class SDCardBuffer {
	//All positions show the next writable element
	short _bufferPosition = 0, _bufferOverrunSize = 0, _bufferOverrunPosition = 0;
	char *_bufferOverrunData = NULL;

	bool _AddToOverrunBuffer(char *data, short size);
	inline short _GetFreeSpaceInBuffer() const;
	inline short _GetFreeSpaceInOverrunBuffer() const;
public:
	char buffer[SD_CARD_SECTOR_SIZE];

	/**
	 * Constructor
	 *
	 * @param overrunBufferSize Size of the overrun buffer (temporary storage while the main buffer is written out)
	 */
	SDCardBuffer(int overrunBufferSize);

	//Copy constructor
	SDCardBuffer(const SDCardBuffer&);
	//Copy assignment operator
	SDCardBuffer& operator=(const SDCardBuffer&);
	//Move constructor
	SDCardBuffer(SDCardBuffer&&);
	//Move assignement operator
	SDCardBuffer& operator=(SDCardBuffer&&);

	~SDCardBuffer();

	/**
	 * Gets the current buffer size
	 *
	 * return Current buffer size
	 */
	short GetBufferSize() const;

	/**
	 * Appends the given data to the buffer, writing anything that doesn't fit into the overrun buffer, if possible
	 *
	 * @param data The data to be written to the buffer
	 * @param size Size of the data
	 * return True, if data is appended, false if the apend would cause an overrun
	 */
	bool AddToBuffer(char *data, short size);

	/**
	 * Checks if the buffer is full
	 *
	 * return True, if the buffer is full
	 */
	bool IsBufferFull() const;

	/**
	 * Discards the current buffer, and replaces it with overrun data, if any
	 *
	 * return Returns the buffer size after discard
	 */
	short DiscardBuffer();
};

class SDHandler {
	static bool _initialized;
	static std::string _currentRunName;
	static std::map<sensor_id, SDCardBuffer> _rideLogMap;
	static FATFS _sdFs;

	inline static std::string _getSensorLogFilePath(sensor_id sensorID) { return _currentRunName + "/Log_" + std::to_string(sensorID) + ".bin"; }

	/**
	 * Dumps all of the unwritten logs from the current ride
	 */
	static void _DumpSensorLogBuffer();

	/**
	 * Appends the given sensor log buffer to the apropriate log file
	 *
	 * @param filename The sensor filename as generated by _getSensorLogFilePath
	 * @param logBuffer The apropriate buffer object
	 * @param writeAll If true, all of the stored data will be written out, otherwise, the write will stop once the active buffer is not full
	 */
	static void _WriteSensorLogBufferToCard(const std::string filename, SDCardBuffer &logBuffer, const bool writeAll);

public:
	/**
	 * Initializes the handler. Must be called before any operations.
	 */
	static void Initialize();

	/**
	 * Dumps any unwritten data, unmounts the SD card and deinitializes this class
	 */
	static void Stop();

	/**
	 * Initializes the run file structure
	 *
	 * @param runStartTime Run start time
	 * @param relevantSensors Sensors that exist on this mote
	 * @param rideConfig Ride configuration
	 */
	static void InitRun(abs_timestamp runStartTime, Sensor *relevantSensors, short sensorCount, RideConfig &rideConfig);

	/**
	 * Stores the given log from a sensor to a buffer, then writes out the buffer, if it is full
	 *
	 * @param sensorID ID of the sensor
	 * @param log sensor log to be stored
	 */
	static void StoreLog(const sensor_id sensorID, const Log &log);

	/**
	 * Dumps all unwritten run data and deinitializes the current run
	 */
	static void StopRun();

	inline static bool IsConfigLocallyStored() {
		if(!_initialized) fatalError("[SDHandler::IsConfigLocallyStored]: SDHandler is not initialized");
		return f_stat(CONFIG_FILENAME, NULL) == FR_OK;
	}

	/**
	 * Gets localy stored settings
	 *
	 * return Localy stored setting object
	 */
	static SettingsVC GetLocalConfig();

	/**
	 * Saves new settings localy
	 *
	 * @param settings The new Settings object
	 */
	static void SaveNewConfig(const Settings &settings);
};

#endif

